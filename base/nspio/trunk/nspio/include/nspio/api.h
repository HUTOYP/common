// copyright:
//            (C) SINA Inc.
//
//           file: nspio/include/nspio/api.h
//           desc: 
//  signed-off-by: Dong Fang <yp.fangdong@gmail.com>
//           date: 2014-02-14


#ifndef _H_NSPIO_
#define _H_NSPIO_

#include <iostream>
#include <inttypes.h>

using namespace std;

#include <nspio/errno.h>


namespace nspio {

enum FLAG_BITS {
    FLAG_BIT1 = 0x0001,
    FLAG_BIT2 = 0x0002,
    FLAG_BIT3 = 0x0004,
    FLAG_BIT4 = 0x0008,
    FLAG_BIT5 = 0x0010,
    FLAG_BIT6 = 0x0020,
    FLAG_BIT7 = 0x0040,
    FLAG_BIT8 = 0x0080,
    FLAG_BIT9 = 0x0100,
    FLAG_BIT10 = 0x0200,
    FLAG_BIT11 = 0x0400,
    FLAG_BIT12 = 0x0800,
    FLAG_BIT13 = 0x1000,
    FLAG_BIT14 = 0x2000,
    FLAG_BIT15 = 0x4000,
    FLAG_BIT16 = 0x8000,
};

enum {
    OPT_TIMEOUT = FLAG_BIT1,
    OPT_NONBLOCK = FLAG_BIT2,
    OPT_AUTORECONNECT = FLAG_BIT3,
    OPT_SOCKCACHE = FLAG_BIT4,
    OPT_KEEPORDER = FLAG_BIT5,
};

struct spiohdr {
    uint8_t version;
    uint8_t ttl;
    uint16_t flags;
    /*
          FLAG_BIT1 = 0x0001,    PIOICMPMSG
	  FLAG_BIT2 = 0x0002,    PIOICMP_ROLEATTR
	  FLAG_BIT3 = 0x0004,    PIOICMP_APPSTATUS
	  FLAG_BIT4 = 0x0008,    PIOICMP_ROLESTATUS
	  FLAG_BIT5 = 0x0010,    SYNCAPIMSG
	  FLAG_BIT6 = 0x0020,    ASYNCAPIMSG
	  FLAG_BIT7 = 0x0040,    APPICMPMSG
	  FLAG_BIT8 = 0x0080,    APPICMP_DELIVERERROR
    */
    uint32_t size;
    uint16_t hdrcheck;
    uint16_t datacheck;
    uint64_t seqid;
    int64_t timestamp;
    union {
	char __padding[8];
    } _u;
};

class Comsumer {
 public:
    virtual ~Comsumer() {}

    // Appid: appname.
    // AppHost: nspio server ip:port address. 
    // When successful, Connect() returns zero. When an error
    // occurs, Connect() returns -1 and _errno is set appropriately.
    virtual int Connect(const string &appname, const string &apphost) = 0;

    // Close() API close the raw socket. you can Connect() to
    // the nspio server again
    virtual int Close() = 0;

    // Recv request massage from nspio server
    // When successful, returns zero. When an error occurs, returns -1
    // and _errno is set appropriately.
    // here rt specify the route infomation
    virtual int Recv(string &msg, string &rt) = 0;

    // Send response massage to nspio server
    // When successful, returns zero. When an error occurs, returns -1
    // and _errno is set appropriately.
    // send msg with rt generated by Recv() API
    virtual int Send(const string &msg, const string &rt) = 0;
    virtual int Send(const char *data, uint32_t len, const string &rt) = 0;

    
    virtual int SetOption(int opt, ...) = 0;
    virtual int GetOption(int opt, ...) = 0;
};

Comsumer *NewComsumer();


class Producer {
 public:
    virtual ~Producer() {}

    // Appid: appname.
    // AppHost: nspio server ip:port address. 
    // When successful, Connect() returns zero. When an error
    // occurs, Connect() returns -1 and _errno is set appropriately.
    virtual int Connect(const string &appname, const string &apphost) = 0;

    // Close() API close the raw socket. you can Connect() to
    // the nspio server again
    virtual int Close() = 0;

    // Send request massage from nspio server
    // When successful, returns zero. When an error occurs, returns -1
    // and _errno is set appropriately.
    virtual int Send(const string &msg) = 0;
    virtual int Send(const char *data, uint32_t len) = 0;

    // Recv response massage to nspio server
    // When successful, returns zero. When an error occurs, returns -1
    // and _errno is set appropriately.
    virtual int Recv(string &msg) = 0;


    virtual int SetOption(int opt, ...) = 0;
    virtual int GetOption(int opt, ...) = 0;
};

Producer *NewProducer();


}
 

#endif  // _H_SPIOCLIENT_
